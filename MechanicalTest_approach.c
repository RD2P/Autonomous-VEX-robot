#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    PhotoSensor,    sensorReflection)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl3,  button2,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarLeftIn,    sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  sonarRightIn,   sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  sonarMiddleIn,  sensorSONAR_cm)
#pragma config(Sensor, dgtl11, LEDGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDRed,         sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  motorL,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           motorR,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           motorL,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motorArm,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed;
bool button2_pushed;
int rightIR;
int leftIR;
int maxIR = 700;
int currentIR;

void monitorInput() {  //monitors which button is being pushed
	if(SensorValue(button1) && !button1_pushed){
		button1_pushed = true;	}

	if(SensorValue(button2) && !button2_pushed)	{
		button2_pushed = true;	}
}

void turnL () {
	resetMotorEncoder(motorL);
	while (getMotorEncoder(motorL) > -300){
		motor[motorL] = -30;
		motor[motorR]= 30;
	}
	motor[motorL] = 0;
	motor[motorR]= 0;
}
void turnR () {
	resetMotorEncoder(motorL);
	while (getMotorEncoder(motorL) < 300){
		motor[motorL] = 30;
		motor[motorR]= -30;
	}
	motor[motorL] = 0;
	motor[motorR]= 0;
}
void slightRight(){
	motor[motorR] = 40;
	motor[motorL] = 50;
	wait1Msec(500);
	leftIR = SensorValue[PhotoSensor];
}
void slightLeft(){
	motor[motorL] = 40;
	motor[motorR] = 50;
	wait1Msec(500);
	rightIR = SensorValue[PhotoSensor];
}

void approach (){
	maxIR = SensorValue[PhotoSensor];
	while(SensorValue(SonarMiddleIn)> 40){
		turnR();
		wait1Msec(500);
		currentIR = SensorValue[PhotoSensor];
		while (currentIR < maxIR){
			motor[motorL] = -10;
			motor[motorR] = 10;
			wait1Msec(100);
			currentIR = SensorValue[PhotoSensor];
		}
	}
}

task main()
{
	button1_pushed = button2_pushed = false;
	resetMotorEncoder(motorL);
	enum T_state {															//Declare states
		STOP,
		CLOSE_IN,
	};

	T_state state = STOP;

	while(true){
		monitorInput();
		switch (state)
		{
		case STOP:
			motor[motorL] = 0;
			motor[motorR] = 0;
			if (button1_pushed) {
				button1_pushed = false;
				state = CLOSE_IN;	}
			break;

		case CLOSE_IN:
			approach();
			state = STOP;
			break;

			//default:

		}
	}


}
