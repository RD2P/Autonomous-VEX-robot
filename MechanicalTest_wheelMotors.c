#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  encoderMotorR,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port9,           motorL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorR,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


void monitorInput() //monitors which button is being pushed
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
	}
}

void turn () {
	while (getMotorEncoder(motorR) < 1150){
		motor[motorL] = 0;
		motor[motorR]= 50;
	}
	motor[motorL] = 0;
	motor[motorR]= 0;
	button2_pushed = false;
	resetMotorEncoder(motorR);
}

void forward () {

	while(getMotorEncoder(motorR)< 1937){
		motor[motorL] = -40;
		motor[motorR]= 50;
	}
	motor[motorL] = 0;
	motor[motorR]= 0;
	button1_pushed = false;
	resetMotorEncoder(motorR);
}

task main {

	button1_pushed = button2_pushed = false;
	resetMotorEncoder(motorR);							//Reset encoder to zero

	enum T_state {															//Declare states
		STOP,
		FORWARD,
		TURN
	};

	T_state state = STOP;


	while (true){

		monitorInput();

		switch (state)
		{
		case STOP:
			motor[motorL] = 0;
			motor[motorR] = 0;
			if (button1_pushed) {
				state = FORWARD;
			}
			if (button2_pushed) {
				state = TURN;
			}
			break;
		case FORWARD:
			forward();
		//	button1_pushed = false;
			state = STOP;
			break;
		case TURN:
			turn();
		//	button2_pushed = false;
			state = STOP;
			break;

			//default:
		}//end switch
	}//end while
}//end task main
