#pragma config(Sensor, in1,    PhotoSensor,    sensorReflection)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl3,  button2,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarLeftIn,    sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  sonarRightIn,   sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  sonarMiddleIn,  sensorSONAR_cm)
#pragma config(Sensor, dgtl11, LEDGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDRed,         sensorLEDtoVCC)
#pragma config(Motor,  port3,           motorR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorL,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motorArm,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed;
bool button2_pushed;

void monitorInput() {  //monitors which button is being pushed
	if(SensorValue(button1) && !button1_pushed){
		button1_pushed = true;	}

	if(SensorValue(button2) && !button2_pushed)	{
		button2_pushed = true;	}
}

void finalApproach(){
	while(SensorValue(sonarMiddleIn)> 4){
		motor[motorL] = 15;
		motor[motorR] = 15;
	}
	motor[motorL] = 0;
	motor[motorR] = 0;
}

void openArm() { 	//Drops ball
	motor [motorArm] = 10;			//arm motor moves for 1.5 s
	wait1Msec(600);
	motor [motorArm]	= 0;
	wait1Msec(1500);
	motor [motorL]	= -20;		//robot backs up for 1.5s and stops
	motor [motorR]	= -20;
	wait1Msec(1500);
}

task main()
{
	button1_pushed = button2_pushed = false;
	resetMotorEncoder(motorL);
	enum T_state {															//Declare states
		STOP,
		CLOSE_IN,
	};

	T_state state = STOP;

	while(true){
		monitorInput();
		switch (state)
		{
		case STOP:
			motor[motorL] = 0;
			motor[motorR] = 0;
			if (button1_pushed) {
				button1_pushed = false;
				state = CLOSE_IN;	}
			break;

		case CLOSE_IN:
			finalApproach();
			openArm();
			state = STOP;
			break;

			default:
		}
	}
}
