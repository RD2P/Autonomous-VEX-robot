#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    PhotoSensor,    sensorReflection)
#pragma config(Sensor, dgtl2,  button,         sensorTouch)
#pragma config(Sensor, dgtl4,  sonarLeftIn,    sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  sonarRightIn,   sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  sonarMiddleIn,  sensorSONAR_cm)
#pragma config(Sensor, dgtl11, LEDGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDRed,         sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorL,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           motorArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorR,        tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int centerSonar;
int rightSonar;
int leftSonar;
bool button_pushed;

void monitorInput() //monitors which button is being pushed
{
	if(SensorValue(button) && !button_pushed)
	{
		button_pushed = true;
	}
}

void slightRight(){
	motor[motorR] = 40;
	motor[motorL] = 60;
	wait1Msec(500);
	left tSonar = SensorValue[sonarMiddleIn];
}
void slightLeft(){
	motor[motorL] = 40;
	motor[motorR] = 60;
	wait1Msec(500);
	rightSonar = SensorValue[sonarMiddleIn];
}

void approach (){

	while(SensorValue(sonarMiddleIn)> 40){
		motor[motorL] = 60;
		motor[motorR] = -60;
		wait1Msec(500);
		rightSonar = SensorValue[sonarMiddleIn];

		motor[motorL] = -60;
		motor[motorR] = 60;
		wait1Msec(1000);
		leftSonar = SensorValue[sonarMiddleIn];

		motor[motorL] = 60;
		motor[motorR] = -60;
		wait1Msec(500);

		if (leftIR > rightIR){
			slightLeft();
		}
		if (leftIR < rightIR){
			slightRight();
		}
	}
}

void openArm() {			//drops the ball cage onto the target
	motor [motorArm] = -10;
	wait1Msec(1500);
	motor [motorArm]	= 0;	//lower the arm
	motor [motorL]	= -40;		//reverse robot
	motor [motorR]	= -40;
	wait1Msec(1500);
	motor [motorL]	= 0;		//motor stop
	motor [motorR]	= 0;
}

task main()
{
	button_pushed = false;
	resetMotorEncoder(motorR);

	//Declare states
	enum T_state {		
		STOP,
		SEARCH,
		CLOSE_IN,
		FINAL_APPROACH,
		DROP,
		EXTRACTION
	};

	T_state state = STOP;


	while (true){

		monitorInput();

		switch (state){
		case STOP:
			motor[motorL] = 0;
			motor[motorR] = 0;
			if (button_pushed) {
				state = SEARCH;
			}
			break;
		case SEARCH:
			if((SensorValue(PhotoSensor))< 600){
				motor[motorL] = 50;
				motor[motorR] = -50;
			}
			if((SensorValue(PhotoSensor))> 600){
				motor[motorL] = -10;
				motor[motorR] = 10;
				wait1Msec(500);
				motor[motorL] = 50;
				motor[motorR] = 50;
				wait1Msec(600);
				motor[motorL] = 0;
				motor[motorR] = 0;
				button_pushed = false;
				state = CLOSE_IN;
			}
			break;

		case CLOSE_IN:
			approach();
			state = FINAL_APPROACH;
			break;

		case FINAL_APPROACH:
			while((SensorValue(sonarMiddleIn)<13) && (SensorValue(sonarMiddleIn)>6)){
				motor[motorL] = 10;
				motor[motorR] = 10;
			}
			motor[motorL] = 0;
			motor[motorR] = 0;
			state = DROP;
			break;

		case DROP:
			openArm();

			//default:
		}
	}
}
